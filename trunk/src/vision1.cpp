/**
 * @author ehtd
 *
 * Version : $Id$
 * This file was generated by Aldebaran Robotics ModuleGenerator
 */

#include <alvalue.h>
#include <alptr.h>
#include <albroker.h>
#include <almodule.h>
#include <string.h>
#include <stdlib.h>

#include "vision1.h"
#include <iostream>
#include <stdio.h>
#include "alproxy.h"

#include "alvision/alvisiondefinitions.h"




//______________________________________________
// constructor
//______________________________________________
vision1::vision1(AL::ALPtr<AL::ALBroker> broker, const std::string& name ): 
AL::ALModule(broker, name ),
fRegisteredToVim(false),
img(NULL)
{
	setModuleDescription( "This is an autogenerated module, this descriptio needs to be updated. " );

	functionName( "takePicture", "vision1" ,  "Takes a picture and saves it." );
	addParam( "imgName", "Image name" );
	BIND_METHOD( vision1::takePicture );

	functionName( "registerToVIM", "vision1" ,  "Takes a picture and saves it." );
	addParam( "imgName", "Image name" );
	BIND_METHOD( vision1::registerToVIM );

	functionName( "init", "vision1" ,  "Takes a picture and saves it." );
	addParam( "imgName", "Image name" );
	BIND_METHOD( vision1::init );

	functionName( "processBall", "vision1" ,  "Takes a picture finds ball and saves it." );
	addParam( "imgName", "Image name" );
	BIND_METHOD( vision1::processBall );

}

//______________________________________________
// destructor
//______________________________________________
vision1::~vision1()
{
	// Release Image Header if client code forgot to call unregisterFromVim.
	if (img)
		cvReleaseImage(&img);
}

void vision1::init() {
	// Create a proxy to the logger module.
	// If this fails, we throw an exception and the module will not be registered.
	try {
		fLogProxy = getParentBroker()->getLoggerProxy();
	} catch (const AL::ALError& e) {
		throw AL::ALError(getName(), "Vision()", "Fail to create a proxy to ALLogger "
				"module. Msg " + e.toString() + "\nModule will abort.");
	}

	// Create a proxy to the video input module.
	try {
		fCamProxy = getParentBroker()->getProxy( "ALVideoDevice" );
	} catch (const AL::ALError& e) {
		throw AL::ALError(getName(), "Vision()", "Could not create a proxy to ALVideoDevice " + e.toString());
	}

}

/**
 * registerToVIM
 */
void vision1::registerToVIM(const int &pResolution, const int &pColorSpace) {

	// If we've already registered a module, we need to unregister it first !
	if (fRegisteredToVim) {
		throw AL::ALError(getName(), "registerToVIM()", "A video module has already been "
				"registered. Call unRegisterFromVIM() before trying to register a new module.");
	}

	// GVM Name that we're going to use to register.
	const std::string kOriginalName = "Borregos_VIM";
	int imgWidth = 0;
	int imgHeight = 0;
	int imgNbLayers = 0;
	const int kImgDepth = 8;
	const int kFps = 30;

	// Release Image Header if it has been allocated before.
	if (img)
		cvReleaseImage(&img);

	AL::getSizeFromResolution(pResolution, imgWidth, imgHeight);
	imgNbLayers = AL::getNumLayersInColorSpace(pColorSpace);

	if (imgWidth == -1 || imgWidth == -1 || imgNbLayers == -1) {
		throw AL::ALError(getName(), "registerToVIM()", "Invalid resolution or color space.");
	}


	// Allocate our Image header.
	img = cvCreateImage(cvSize(imgWidth, imgHeight), kImgDepth,imgNbLayers);
	/*
  if (!img) {
    throw AL::ALError(getName(), "registerToVIM()", "Fail to allocate OpenCv image header.");
  }*/

	// Call the "subscribe" function with the given parameters.
	fGvmName = fCamProxy->call<std::string>("subscribe", kOriginalName,
			pResolution, pColorSpace, kFps );

	fLogProxy->info(getName(), " module registered as " + fGvmName);

	// Registration is successful, set fRegisteredToVim to true.
	fRegisteredToVim = true;
}





/**
 * unRegisterFromVIM
 */
void vision1::unRegisterFromVIM() {

	if (!fRegisteredToVim) {
		throw AL::ALError(getName(), "unRegisterFromVIM()", "No video module is currently "
				"registered! Call registerToVIM first.");
	}

	// Release Image Header if it has been allocated.
	if (img)
		cvReleaseImage(&img);

	fLogProxy->info(getName(), "try to unregister " + fGvmName + " module." );
	fCamProxy->callVoid("unsubscribe", fGvmName);
	fLogProxy->info(getName(), "Done.");

	// UnRegistration is successful, set fRegisteredToVim to false.
	fRegisteredToVim = false;
}

void vision1::getImage(){
	if (!fRegisteredToVim) {
		throw AL::ALError(getName(), "saveImage()",  "No video module is currently "
				"registered! Call registerToVIM() first.");
	}

	imageIn = NULL;

	// Now you can get the pointer to the video structure.
	imageIn = (AL::ALImage*) (fCamProxy->call<int>("getImageLocal", fGvmName));

	if (!imageIn) {
		throw AL::ALError(getName(), "saveImage", "Invalid image returned.");
	}


	//fLogProxy->info(getName(), imageIn->toString());

	// Set the buffer we received to our IplImage header.
	img->imageData = (char*)imageIn->getFrame();
	/*
  int imgWidth = imageIn->fWidth;
  int imgHeight = imageIn->fHeight;
  int imgNbLayers = imageIn->fNbLayers;

  img = cvCreateImage(cvSize(imgWidth, imgHeight), 8 ,imgNbLayers);*/

}

void vision1::saveImage(const std::string& path){
	try {
		const int seconds = (int)(imageIn->fTimeStamp/1000000LL);
		const std::string kImageNameFull = path + DecToString(seconds) + ".jpg";
		cvSaveImage(kImageNameFull.c_str(), img);
		//		 detectBall(img);
		fLogProxy->info(getName(), "Image saved as foto.jpg");
	}
	catch(...) {
		throw AL::ALError(getName(), "saveIplImage()", "OpenCV can't save the image with "
				"this format.");
	}
}

void vision1::saveImage(const std::string& path, IplImage* imagen){
	try {
		const int seconds = (int)(imageIn->fTimeStamp/1000000LL);
		const std::string kImageNameFull = path + DecToString(seconds) + ".jpg";
		cvSaveImage(kImageNameFull.c_str(), imagen);
		//		 detectBall(img);
		fLogProxy->info(getName(), "Image saved as foto.jpg");
	}
	catch(...) {
		throw AL::ALError(getName(), "saveIplImage()", "OpenCV can't save the image with "
				"this format.");
	}
}

void vision1::write(){
	FILE *pFile;
	char buffer[] = {'x','y','z'};
	pFile = fopen ("myfile.bin","wb");
	fwrite(buffer ,1, sizeof(buffer),pFile);
	fclose(pFile);
}


//IplImage* vision1::detectBall(IplImage* img1){
//			IplImage* dst = cvCreateImage(cvSize(img1->width, img1->height), img1->depth, img1->nChannels);
//			//cvPyrMeanShiftFiltering(frame,segmented,10,70);
//			CvMemStorage* storage = cvCreateMemStorage(0);
//			CvSeq* comp = NULL;
//			cvPyrSegmentation(img1,dst,storage,&comp,4,150,30);
//			int n_comp = comp->total;
//			for( int i=0; i<n_comp; i++ ) {
//				CvConnectedComp* cc = (CvConnectedComp*) cvGetSeqElem( comp, i );
//				if (cc->value.val[0] < 100 && cc->value.val[0] > 20 && cc->value.val[1] > 100 && cc->value.val[1] < 170 && cc->value.val[2] > 150 && cc->value.val[2] < 220){
//					fLogProxy->info(getName(), "Pelota encontrada");
//					CvPoint pt1 = cvPoint(cc->rect.x,cc->rect.y);
//					CvPoint pt2 = cvPoint(cc->rect.x+cc->rect.width,cc->rect.y+cc->rect.height);
//					cvRectangle(dst,pt1,pt2,CV_RGB(255,0,0));
////					cvSaveImage("/home/nao/data/foto.jpg", img1);
//					//printf("%f - %f %f %f \n",cc->area,cc->value.val[0],cc->value.val[1],cc->value.val[2]);
//				}
//			}
//			cvReleaseMemStorage( &storage );
//}


void vision1::releaseImage(){
	cvReleaseImage(&img);
}

void vision1::takePicture(const std::string& path){
	init();
	fLogProxy->info(getName(), "registerToVIM");
	registerToVIM(AL::kVGA, AL::kRGBColorSpace);
	fLogProxy->info(getName(), "getImage");
	getImage();
	fLogProxy->info(getName(), "saveImage");
	saveImage(path);
	fLogProxy->info(getName(), "releaseImage");
	releaseImage();
	fLogProxy->info(getName(), "unRegisterFromVIM");
	unRegisterFromVIM();
}

void vision1::processBall(const std::string& path){
	init();
	fLogProxy->info(getName(), "registerToVIM");
	registerToVIM(AL::kVGA, AL::kHSYColorSpace);
	fLogProxy->info(getName(), "getImage");
	getImage();
	fLogProxy->info(getName(), "detectBall");
	detectBall();
	fLogProxy->info(getName(), "saveImage");
	saveImage(path);
	fLogProxy->info(getName(), "releaseImage");
	releaseImage();
	fLogProxy->info(getName(), "unRegisterFromVIM");
	unRegisterFromVIM();
}

void vision1::detectBall(){
	for( int y=0; y<img->height; y++ ) {
		uchar* ptr = (uchar*) (img->imageData + y * img->widthStep);
		for( int x=0; x<img->width; x++ ) {
			if (ptr [3*x+0]< 60 and ptr [3*x+0]> 15 and ptr [3*x+1]> 90){
				ptr[3*x+0] = 30;
				ptr[3*x+1] = 255;
				ptr[3*x+2] = 255;
			}
			else{
				ptr[3*x+0] = 0;
				ptr[3*x+1] = 0;
				ptr[3*x+2] = 0;
			}
		}
	}
}


//IplImage* vision1::detectBall(){
//	IplImage* dst = cvCreateImage(cvSize(img->width, img->height), img->depth, img->nChannels); //se crea la imagen destino
//	//cvPyrMeanShiftFiltering(frame,segmented,10,70);
//	CvMemStorage* storage = cvCreateMemStorage(0);//se  tiene q hacer para usar el metodo de segmentacion
//	CvSeq* comp = NULL; //se usa en el metodo de segmentacion
//	cvPyrSegmentation(img,dst,storage,&comp,4,150,30); //funcion que segmenta la imagen img y la guarda en dst
////	int n_comp = comp->total; //el total de regiones que hay en la imagen
///*	for( int i=0; i<n_comp; i++ ) {//para cada region ejecuta lo siguiente
//		CvConnectedComp* cc = (CvConnectedComp*) cvGetSeqElem( comp, i );//obtiene la region i
//		//verifica que el color promedio de la regiÃ³n (RGB) sea como naranja
//		if (cc->value.val[0] < 100 && cc->value.val[0] > 20 && cc->value.val[1] > 100 && cc->value.val[1] < 170 && cc->value.val[2] > 150 && cc->value.val[2] < 220){
//			CvPoint pt1 = cvPoint(cc->rect.x,cc->rect.y); //obtiene el punto superior izquierdo del bounding box de la region
//			CvPoint pt2 = cvPoint(cc->rect.x+cc->rect.width,cc->rect.y+cc->rect.height); //obtiene el punto inferior izq del bounding box de la region
//			cvRectangle(dst,pt1,pt2,CV_RGB(255,0,0)); //dibuja el bounding box de la region
//			//printf("%f - %f %f %f \n",cc->area,cc->value.val[0],cc->value.val[1],cc->value.val[2]);
//		}
//	}*/
//	cvReleaseMemStorage( &storage );
//	return dst;
//}

/**
 * dummy Function
 * @param pMsg Message to show on screen
 * @param pNawak the function will return this parameter
 * @return an alvalue
 */
AL::ALValue vision1::dummyFunction( const std::string& pMsg, const AL::ALValue& pFoo )
{
	std::cout << "vision1 say : " << pMsg << std::endl;
	if( pFoo.isValid() )
		std::cout << "Return value: " << pFoo.toString( AL::VerbosityMini ) << std::endl;
	else
		std::cout << "The value you send me is invalid" << std::endl;

	return pFoo;
}
